<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Grbl9d-c: stepper.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>stepper.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  stepper.c - stepper motor driver: executes motion plans using stepper motors</span>
<a name="l00003"></a>00003 <span class="comment">  Part of Grbl</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  Copyright (c) 2011-2014 Sungeun K. Jeon</span>
<a name="l00006"></a>00006 <span class="comment">  Copyright (c) 2009-2011 Simen Svale Skogsrud</span>
<a name="l00007"></a>00007 <span class="comment">  </span>
<a name="l00008"></a>00008 <span class="comment">  Grbl is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment">  the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00011"></a>00011 <span class="comment">  (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">  Grbl is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">  GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">  You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;system.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;nuts_bolts.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;stepper.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;settings.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;planner.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;probe.h&quot;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">// Some useful constants.</span>
<a name="l00031"></a>00031 <span class="preprocessor">#define DT_SEGMENT (1.0/(ACCELERATION_TICKS_PER_SECOND*60.0)) // min/segment </span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#define REQ_MM_INCREMENT_SCALAR 1.25                                   </span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#define RAMP_ACCEL 0</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#define RAMP_CRUISE 1</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#define RAMP_DECEL 2</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="comment">// Define Adaptive Multi-Axis Step-Smoothing(AMASS) levels and cutoff frequencies. The highest level</span>
<a name="l00038"></a>00038 <span class="comment">// frequency bin starts at 0Hz and ends at its cutoff frequency. The next lower level frequency bin</span>
<a name="l00039"></a>00039 <span class="comment">// starts at the next higher cutoff frequency, and so on. The cutoff frequencies for each level must</span>
<a name="l00040"></a>00040 <span class="comment">// be considered carefully against how much it over-drives the stepper ISR, the accuracy of the 16-bit</span>
<a name="l00041"></a>00041 <span class="comment">// timer, and the CPU overhead. Level 0 (no AMASS, normal operation) frequency bin starts at the </span>
<a name="l00042"></a>00042 <span class="comment">// Level 1 cutoff frequency and up to as fast as the CPU allows (over 30kHz in limited testing).</span>
<a name="l00043"></a>00043 <span class="comment">// NOTE: AMASS cutoff frequency multiplied by ISR overdrive factor must not exceed maximum step frequency.</span>
<a name="l00044"></a>00044 <span class="comment">// NOTE: Current settings are set to overdrive the ISR to no more than 16kHz, balancing CPU overhead</span>
<a name="l00045"></a>00045 <span class="comment">// and timer accuracy.  Do not alter these settings unless you know what you are doing.</span>
<a name="l00046"></a>00046 <span class="preprocessor">#define MAX_AMASS_LEVEL 3</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="comment">// AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.</span>
<a name="l00048"></a>00048 <span class="preprocessor">#define AMASS_LEVEL1 (F_CPU/8000) // Over-drives ISR (x2). Defined as F_CPU/(Cutoff frequency in Hz)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define AMASS_LEVEL2 (F_CPU/4000) // Over-drives ISR (x4)</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define AMASS_LEVEL3 (F_CPU/2000) // Over-drives ISR (x8)</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">// Stores the planner block Bresenham algorithm execution data for the segments in the segment </span>
<a name="l00054"></a>00054 <span class="comment">// buffer. Normally, this buffer is partially in-use, but, for the worst case scenario, it will</span>
<a name="l00055"></a>00055 <span class="comment">// never exceed the number of accessible stepper buffer segments (SEGMENT_BUFFER_SIZE-1).</span>
<a name="l00056"></a>00056 <span class="comment">// NOTE: This data is copied from the prepped planner blocks so that the planner blocks may be</span>
<a name="l00057"></a>00057 <span class="comment">// discarded when entirely consumed and completed by the segment buffer. Also, AMASS alters this</span>
<a name="l00058"></a>00058 <span class="comment">// data for its own use. </span>
<a name="l00059"></a>00059 <span class="keyword">typedef</span> <span class="keyword">struct </span>{  
<a name="l00060"></a>00060   uint8_t direction_bits;
<a name="l00061"></a>00061   uint32_t steps[N_AXIS];
<a name="l00062"></a>00062   uint32_t step_event_count;
<a name="l00063"></a>00063 } st_block_t;
<a name="l00064"></a>00064 <span class="keyword">static</span> st_block_t st_block_buffer[SEGMENT_BUFFER_SIZE-1];
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">// Primary stepper segment ring buffer. Contains small, short line segments for the stepper </span>
<a name="l00067"></a>00067 <span class="comment">// algorithm to execute, which are &quot;checked-out&quot; incrementally from the first block in the</span>
<a name="l00068"></a>00068 <span class="comment">// planner buffer. Once &quot;checked-out&quot;, the steps in the segments buffer cannot be modified by </span>
<a name="l00069"></a>00069 <span class="comment">// the planner, where the remaining planner block steps still can.</span>
<a name="l00070"></a>00070 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00071"></a>00071   uint16_t n_step;          <span class="comment">// Number of step events to be executed for this segment</span>
<a name="l00072"></a>00072   uint8_t st_block_index;   <span class="comment">// Stepper block data index. Uses this information to execute this segment.</span>
<a name="l00073"></a>00073   uint16_t cycles_per_tick; <span class="comment">// Step distance traveled per ISR tick, aka step rate.</span>
<a name="l00074"></a>00074 <span class="preprocessor">  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>    uint8_t amass_level;    <span class="comment">// Indicates AMASS level for the ISR to execute this segment</span>
<a name="l00076"></a>00076 <span class="preprocessor">  #else</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>    uint8_t prescaler;      <span class="comment">// Without AMASS, a prescaler is required to adjust for slow timing.</span>
<a name="l00078"></a>00078 <span class="preprocessor">  #endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>} segment_t;
<a name="l00080"></a>00080 <span class="keyword">static</span> segment_t segment_buffer[SEGMENT_BUFFER_SIZE];
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="comment">// Stepper ISR data struct. Contains the running data for the main stepper ISR.</span>
<a name="l00083"></a>00083 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00084"></a>00084   <span class="comment">// Used by the bresenham line algorithm</span>
<a name="l00085"></a>00085   uint32_t counter_x,        <span class="comment">// Counter variables for the bresenham line tracer</span>
<a name="l00086"></a>00086            counter_y, 
<a name="l00087"></a>00087            counter_z;
<a name="l00088"></a>00088 <span class="preprocessor">  #ifdef STEP_PULSE_DELAY</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>    uint8_t step_bits;  <span class="comment">// Stores out_bits output to complete the step pulse delay</span>
<a name="l00090"></a>00090 <span class="preprocessor">  #endif</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>  
<a name="l00092"></a>00092   uint8_t execute_step;     <span class="comment">// Flags step execution for each interrupt.</span>
<a name="l00093"></a>00093   uint8_t step_pulse_time;  <span class="comment">// Step pulse reset time after step rise</span>
<a name="l00094"></a>00094   uint8_t step_outbits;         <span class="comment">// The next stepping-bits to be output</span>
<a name="l00095"></a>00095   uint8_t dir_outbits;
<a name="l00096"></a>00096 <span class="preprocessor">  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>    uint32_t steps[N_AXIS];
<a name="l00098"></a>00098 <span class="preprocessor">  #endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>
<a name="l00100"></a>00100   uint16_t step_count;       <span class="comment">// Steps remaining in line segment motion  </span>
<a name="l00101"></a>00101   uint8_t exec_block_index; <span class="comment">// Tracks the current st_block index. Change indicates new block.</span>
<a name="l00102"></a>00102   st_block_t *exec_block;   <span class="comment">// Pointer to the block data for the segment being executed</span>
<a name="l00103"></a>00103   segment_t *exec_segment;  <span class="comment">// Pointer to the segment being executed</span>
<a name="l00104"></a>00104 } stepper_t;
<a name="l00105"></a>00105 <span class="keyword">static</span> stepper_t st;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">// Step segment ring buffer indices</span>
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">volatile</span> uint8_t segment_buffer_tail;
<a name="l00109"></a>00109 <span class="keyword">static</span> uint8_t segment_buffer_head;
<a name="l00110"></a>00110 <span class="keyword">static</span> uint8_t segment_next_head;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">// Used to avoid ISR nesting of the &quot;Stepper Driver Interrupt&quot;. Should never occur though.</span>
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keyword">volatile</span> uint8_t busy;   
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">// Pointers for the step segment being prepped from the planner buffer. Accessed only by the</span>
<a name="l00116"></a>00116 <span class="comment">// main program. Pointers may be planning segments or planner blocks ahead of what being executed.</span>
<a name="l00117"></a>00117 <span class="keyword">static</span> <a class="code" href="structplan__block__t.html">plan_block_t</a> *pl_block;     <span class="comment">// Pointer to the planner block being prepped</span>
<a name="l00118"></a>00118 <span class="keyword">static</span> st_block_t *st_prep_block;  <span class="comment">// Pointer to the stepper block data being prepped </span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">// Segment preparation data struct. Contains all the necessary information to compute new segments</span>
<a name="l00121"></a>00121 <span class="comment">// based on the current executing planner block.</span>
<a name="l00122"></a>00122 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00123"></a>00123   uint8_t st_block_index;  <span class="comment">// Index of stepper common data block being prepped</span>
<a name="l00124"></a>00124   uint8_t flag_partial_block;  <span class="comment">// Flag indicating the last block completed. Time to load a new one.</span>
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   <span class="keywordtype">float</span> steps_remaining;
<a name="l00127"></a>00127   <span class="keywordtype">float</span> step_per_mm;           <span class="comment">// Current planner block step/millimeter conversion scalar</span>
<a name="l00128"></a>00128   <span class="keywordtype">float</span> req_mm_increment;
<a name="l00129"></a>00129   <span class="keywordtype">float</span> dt_remainder;
<a name="l00130"></a>00130   
<a name="l00131"></a>00131   uint8_t ramp_type;      <span class="comment">// Current segment ramp state</span>
<a name="l00132"></a>00132   <span class="keywordtype">float</span> mm_complete;      <span class="comment">// End of velocity profile from end of current planner block in (mm).</span>
<a name="l00133"></a>00133                           <span class="comment">// NOTE: This value must coincide with a step(no mantissa) when converted.</span>
<a name="l00134"></a>00134   <span class="keywordtype">float</span> current_speed;    <span class="comment">// Current speed at the end of the segment buffer (mm/min)</span>
<a name="l00135"></a>00135   <span class="keywordtype">float</span> maximum_speed;    <span class="comment">// Maximum speed of executing block. Not always nominal speed. (mm/min)</span>
<a name="l00136"></a>00136   <span class="keywordtype">float</span> exit_speed;       <span class="comment">// Exit speed of executing block (mm/min)</span>
<a name="l00137"></a>00137   <span class="keywordtype">float</span> accelerate_until; <span class="comment">// Acceleration ramp end measured from end of block (mm)</span>
<a name="l00138"></a>00138   <span class="keywordtype">float</span> decelerate_after; <span class="comment">// Deceleration ramp start measured from end of block (mm)</span>
<a name="l00139"></a>00139 } st_prep_t;
<a name="l00140"></a>00140 <span class="keyword">static</span> st_prep_t prep;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="comment">/*    BLOCK VELOCITY PROFILE DEFINITION </span>
<a name="l00144"></a>00144 <span class="comment">          __________________________</span>
<a name="l00145"></a>00145 <span class="comment">         /|                        |\     _________________         ^</span>
<a name="l00146"></a>00146 <span class="comment">        / |                        | \   /|               |\        |</span>
<a name="l00147"></a>00147 <span class="comment">       /  |                        |  \ / |               | \       s</span>
<a name="l00148"></a>00148 <span class="comment">      /   |                        |   |  |               |  \      p</span>
<a name="l00149"></a>00149 <span class="comment">     /    |                        |   |  |               |   \     e</span>
<a name="l00150"></a>00150 <span class="comment">    +-----+------------------------+---+--+---------------+----+    e</span>
<a name="l00151"></a>00151 <span class="comment">    |               BLOCK 1            ^      BLOCK 2          |    d</span>
<a name="l00152"></a>00152 <span class="comment">                                       |</span>
<a name="l00153"></a>00153 <span class="comment">                  time -----&gt;      EXAMPLE: Block 2 entry speed is at max junction velocity</span>
<a name="l00154"></a>00154 <span class="comment">  </span>
<a name="l00155"></a>00155 <span class="comment">  The planner block buffer is planned assuming constant acceleration velocity profiles and are</span>
<a name="l00156"></a>00156 <span class="comment">  continuously joined at block junctions as shown above. However, the planner only actively computes</span>
<a name="l00157"></a>00157 <span class="comment">  the block entry speeds for an optimal velocity plan, but does not compute the block internal</span>
<a name="l00158"></a>00158 <span class="comment">  velocity profiles. These velocity profiles are computed ad-hoc as they are executed by the </span>
<a name="l00159"></a>00159 <span class="comment">  stepper algorithm and consists of only 7 possible types of profiles: cruise-only, cruise-</span>
<a name="l00160"></a>00160 <span class="comment">  deceleration, acceleration-cruise, acceleration-only, deceleration-only, full-trapezoid, and </span>
<a name="l00161"></a>00161 <span class="comment">  triangle(no cruise).</span>
<a name="l00162"></a>00162 <span class="comment"></span>
<a name="l00163"></a>00163 <span class="comment">                                        maximum_speed (&lt; nominal_speed) -&gt;  + </span>
<a name="l00164"></a>00164 <span class="comment">                    +--------+ &lt;- maximum_speed (= nominal_speed)          /|\                                         </span>
<a name="l00165"></a>00165 <span class="comment">                   /          \                                           / | \                      </span>
<a name="l00166"></a>00166 <span class="comment"> current_speed -&gt; +            \                                         /  |  + &lt;- exit_speed</span>
<a name="l00167"></a>00167 <span class="comment">                  |             + &lt;- exit_speed                         /   |  |                       </span>
<a name="l00168"></a>00168 <span class="comment">                  +-------------+                     current_speed -&gt; +----+--+                   </span>
<a name="l00169"></a>00169 <span class="comment">                   time --&gt;  ^  ^                                           ^  ^                       </span>
<a name="l00170"></a>00170 <span class="comment">                             |  |                                           |  |                       </span>
<a name="l00171"></a>00171 <span class="comment">                decelerate_after(in mm)                             decelerate_after(in mm)</span>
<a name="l00172"></a>00172 <span class="comment">                    ^           ^                                           ^  ^</span>
<a name="l00173"></a>00173 <span class="comment">                    |           |                                           |  |</span>
<a name="l00174"></a>00174 <span class="comment">                accelerate_until(in mm)                             accelerate_until(in mm)</span>
<a name="l00175"></a>00175 <span class="comment">                    </span>
<a name="l00176"></a>00176 <span class="comment">  The step segment buffer computes the executing block velocity profile and tracks the critical</span>
<a name="l00177"></a>00177 <span class="comment">  parameters for the stepper algorithm to accurately trace the profile. These critical parameters </span>
<a name="l00178"></a>00178 <span class="comment">  are shown and defined in the above illustration.</span>
<a name="l00179"></a>00179 <span class="comment">*/</span>
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">// Stepper state initialization. Cycle should only start if the st.cycle_start flag is</span>
<a name="l00183"></a>00183 <span class="comment">// enabled. Startup init and limits call this function but shouldn&#39;t start the cycle.</span>
<a name="l00184"></a>00184 <span class="keywordtype">void</span> st_wake_up() 
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186   <span class="comment">// Enable stepper drivers.</span>
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (bit_istrue(settings.<a class="code" href="structsettings__t.html#a3c9e2fd6617055d94e1b5047a33f4fd3">flags</a>,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1&lt;&lt;STEPPERS_DISABLE_BIT); }
<a name="l00188"></a>00188   <span class="keywordflow">else</span> { STEPPERS_DISABLE_PORT &amp;= ~(1&lt;&lt;STEPPERS_DISABLE_BIT); }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="keywordflow">if</span> (sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> &amp; (STATE_CYCLE | STATE_HOMING)){
<a name="l00191"></a>00191     <span class="comment">// Initialize stepper output bits</span>
<a name="l00192"></a>00192     st.dir_outbits = settings.<a class="code" href="structsettings__t.html#abcdfd1cefdf0eb794c1e5a5713189f15">dir_invert_mask</a>; 
<a name="l00193"></a>00193     st.step_outbits = settings.<a class="code" href="structsettings__t.html#aa843f4bd49fde79b30a7b414f2ebc990">step_invert_mask</a>;
<a name="l00194"></a>00194     
<a name="l00195"></a>00195     <span class="comment">// Initialize step pulse timing from settings. Here to ensure updating after re-writing.</span>
<a name="l00196"></a>00196 <span class="preprocessor">    #ifdef STEP_PULSE_DELAY</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>      <span class="comment">// Set total step pulse time after direction pin set. Ad hoc computation from oscilloscope.</span>
<a name="l00198"></a>00198       st.step_pulse_time = -(((settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) &gt;&gt; 3);
<a name="l00199"></a>00199       <span class="comment">// Set delay between direction pin write and step command.</span>
<a name="l00200"></a>00200       OCR0A = -(((settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>)*TICKS_PER_MICROSECOND) &gt;&gt; 3);
<a name="l00201"></a>00201 <span class="preprocessor">    #else // Normal operation</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>      <span class="comment">// Set step pulse time. Ad hoc computation from oscilloscope. Uses two&#39;s complement.</span>
<a name="l00203"></a>00203       st.step_pulse_time = -(((settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>-2)*TICKS_PER_MICROSECOND) &gt;&gt; 3);
<a name="l00204"></a>00204 <span class="preprocessor">    #endif</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>
<a name="l00206"></a>00206     <span class="comment">// Enable Stepper Driver Interrupt</span>
<a name="l00207"></a>00207     TIMSK1 |= (1&lt;&lt;OCIE1A);
<a name="l00208"></a>00208   }
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">// Stepper shutdown</span>
<a name="l00213"></a>00213 <span class="keywordtype">void</span> st_go_idle() 
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215   <span class="comment">// Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.</span>
<a name="l00216"></a>00216   TIMSK1 &amp;= ~(1&lt;&lt;OCIE1A); <span class="comment">// Disable Timer1 interrupt</span>
<a name="l00217"></a>00217   TCCR1B = (TCCR1B &amp; ~((1&lt;&lt;CS12) | (1&lt;&lt;CS11))) | (1&lt;&lt;CS10); <span class="comment">// Reset clock to no prescaling.</span>
<a name="l00218"></a>00218   busy = <span class="keyword">false</span>;
<a name="l00219"></a>00219   
<a name="l00220"></a>00220   <span class="comment">// Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.</span>
<a name="l00221"></a>00221   <span class="keywordtype">bool</span> pin_state = <span class="keyword">false</span>; <span class="comment">// Keep enabled.</span>
<a name="l00222"></a>00222   <span class="keywordflow">if</span> (((settings.<a class="code" href="structsettings__t.html#a7226c7787679e6a130497217ece0a28a">stepper_idle_lock_time</a> != 0xff) || bit_istrue(sys.<a class="code" href="structsystem__t.html#aae3b4cb19307826b687519919f1c8e4f">execute</a>,EXEC_ALARM)) &amp;&amp; sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> != STATE_HOMING) {
<a name="l00223"></a>00223     <span class="comment">// Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete</span>
<a name="l00224"></a>00224     <span class="comment">// stop and not drift from residual inertial forces at the end of the last movement.</span>
<a name="l00225"></a>00225     delay_ms(settings.<a class="code" href="structsettings__t.html#a7226c7787679e6a130497217ece0a28a">stepper_idle_lock_time</a>);
<a name="l00226"></a>00226     pin_state = <span class="keyword">true</span>; <span class="comment">// Override. Disable steppers.</span>
<a name="l00227"></a>00227   }
<a name="l00228"></a>00228   <span class="keywordflow">if</span> (bit_istrue(settings.<a class="code" href="structsettings__t.html#a3c9e2fd6617055d94e1b5047a33f4fd3">flags</a>,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } <span class="comment">// Apply pin invert.</span>
<a name="l00229"></a>00229   <span class="keywordflow">if</span> (pin_state) { STEPPERS_DISABLE_PORT |= (1&lt;&lt;STEPPERS_DISABLE_BIT); }
<a name="l00230"></a>00230   <span class="keywordflow">else</span> { STEPPERS_DISABLE_PORT &amp;= ~(1&lt;&lt;STEPPERS_DISABLE_BIT); }
<a name="l00231"></a>00231 }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="comment">/* &quot;The Stepper Driver Interrupt&quot; - This timer interrupt is the workhorse of Grbl. Grbl employs</span>
<a name="l00235"></a>00235 <span class="comment">   the venerable Bresenham line algorithm to manage and exactly synchronize multi-axis moves.</span>
<a name="l00236"></a>00236 <span class="comment">   Unlike the popular DDA algorithm, the Bresenham algorithm is not susceptible to numerical</span>
<a name="l00237"></a>00237 <span class="comment">   round-off errors and only requires fast integer counters, meaning low computational overhead</span>
<a name="l00238"></a>00238 <span class="comment">   and maximizing the Arduino&#39;s capabilities. However, the downside of the Bresenham algorithm</span>
<a name="l00239"></a>00239 <span class="comment">   is, for certain multi-axis motions, the non-dominant axes may suffer from un-smooth step </span>
<a name="l00240"></a>00240 <span class="comment">   pulse trains, or aliasing, which can lead to strange audible noises or shaking. This is </span>
<a name="l00241"></a>00241 <span class="comment">   particularly noticeable or may cause motion issues at low step frequencies (0-5kHz), but </span>
<a name="l00242"></a>00242 <span class="comment">   is usually not a physical problem at higher frequencies, although audible.</span>
<a name="l00243"></a>00243 <span class="comment">     To improve Bresenham multi-axis performance, Grbl uses what we call an Adaptive Multi-Axis</span>
<a name="l00244"></a>00244 <span class="comment">   Step Smoothing (AMASS) algorithm, which does what the name implies. At lower step frequencies,</span>
<a name="l00245"></a>00245 <span class="comment">   AMASS artificially increases the Bresenham resolution without effecting the algorithm&#39;s </span>
<a name="l00246"></a>00246 <span class="comment">   innate exactness. AMASS adapts its resolution levels automatically depending on the step</span>
<a name="l00247"></a>00247 <span class="comment">   frequency to be executed, meaning that for even lower step frequencies the step smoothing </span>
<a name="l00248"></a>00248 <span class="comment">   level increases. Algorithmically, AMASS is acheived by a simple bit-shifting of the Bresenham</span>
<a name="l00249"></a>00249 <span class="comment">   step count for each AMASS level. For example, for a Level 1 step smoothing, we bit shift </span>
<a name="l00250"></a>00250 <span class="comment">   the Bresenham step event count, effectively multiplying it by 2, while the axis step counts </span>
<a name="l00251"></a>00251 <span class="comment">   remain the same, and then double the stepper ISR frequency. In effect, we are allowing the</span>
<a name="l00252"></a>00252 <span class="comment">   non-dominant Bresenham axes step in the intermediate ISR tick, while the dominant axis is </span>
<a name="l00253"></a>00253 <span class="comment">   stepping every two ISR ticks, rather than every ISR tick in the traditional sense. At AMASS</span>
<a name="l00254"></a>00254 <span class="comment">   Level 2, we simply bit-shift again, so the non-dominant Bresenham axes can step within any </span>
<a name="l00255"></a>00255 <span class="comment">   of the four ISR ticks, the dominant axis steps every four ISR ticks, and quadruple the </span>
<a name="l00256"></a>00256 <span class="comment">   stepper ISR frequency. And so on. This, in effect, virtually eliminates multi-axis aliasing </span>
<a name="l00257"></a>00257 <span class="comment">   issues with the Bresenham algorithm and does not significantly alter Grbl&#39;s performance, but </span>
<a name="l00258"></a>00258 <span class="comment">   in fact, more efficiently utilizes unused CPU cycles overall throughout all configurations.</span>
<a name="l00259"></a>00259 <span class="comment">     AMASS retains the Bresenham algorithm exactness by requiring that it always executes a full</span>
<a name="l00260"></a>00260 <span class="comment">   Bresenham step, regardless of AMASS Level. Meaning that for an AMASS Level 2, all four </span>
<a name="l00261"></a>00261 <span class="comment">   intermediate steps must be completed such that baseline Bresenham (Level 0) count is always </span>
<a name="l00262"></a>00262 <span class="comment">   retained. Similarly, AMASS Level 3 means all eight intermediate steps must be executed. </span>
<a name="l00263"></a>00263 <span class="comment">   Although the AMASS Levels are in reality arbitrary, where the baseline Bresenham counts can</span>
<a name="l00264"></a>00264 <span class="comment">   be multiplied by any integer value, multiplication by powers of two are simply used to ease </span>
<a name="l00265"></a>00265 <span class="comment">   CPU overhead with bitshift integer operations. </span>
<a name="l00266"></a>00266 <span class="comment">     This interrupt is simple and dumb by design. All the computational heavy-lifting, as in</span>
<a name="l00267"></a>00267 <span class="comment">   determining accelerations, is performed elsewhere. This interrupt pops pre-computed segments,</span>
<a name="l00268"></a>00268 <span class="comment">   defined as constant velocity over n number of steps, from the step segment buffer and then </span>
<a name="l00269"></a>00269 <span class="comment">   executes them by pulsing the stepper pins appropriately via the Bresenham algorithm. This </span>
<a name="l00270"></a>00270 <span class="comment">   ISR is supported by The Stepper Port Reset Interrupt which it uses to reset the stepper port</span>
<a name="l00271"></a>00271 <span class="comment">   after each pulse. The bresenham line tracer algorithm controls all stepper outputs</span>
<a name="l00272"></a>00272 <span class="comment">   simultaneously with these two interrupts.</span>
<a name="l00273"></a>00273 <span class="comment">   </span>
<a name="l00274"></a>00274 <span class="comment">   NOTE: This interrupt must be as efficient as possible and complete before the next ISR tick, </span>
<a name="l00275"></a>00275 <span class="comment">   which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in </span>
<a name="l00276"></a>00276 <span class="comment">   ISR is 5usec typical and 25usec maximum, well below requirement.</span>
<a name="l00277"></a>00277 <span class="comment">   NOTE: This ISR expects at least one step to be executed per segment.</span>
<a name="l00278"></a>00278 <span class="comment">*/</span>
<a name="l00279"></a>00279 <span class="comment">// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller</span>
<a name="l00280"></a>00280 <span class="comment">// int8 variables and update position counters only when a segment completes. This can get complicated </span>
<a name="l00281"></a>00281 <span class="comment">// with probing and homing cycles that require true real-time positions.</span>
<a name="l00282"></a>00282 ISR(TIMER1_COMPA_vect)
<a name="l00283"></a>00283 {        
<a name="l00284"></a>00284 <span class="comment">// SPINDLE_ENABLE_PORT ^= 1&lt;&lt;SPINDLE_ENABLE_BIT; // Debug: Used to time ISR</span>
<a name="l00285"></a>00285   <span class="keywordflow">if</span> (busy) { <span class="keywordflow">return</span>; } <span class="comment">// The busy-flag is used to avoid reentering this interrupt</span>
<a name="l00286"></a>00286   
<a name="l00287"></a>00287   <span class="comment">// Set the direction pins a couple of nanoseconds before we step the steppers</span>
<a name="l00288"></a>00288   DIRECTION_PORT = (DIRECTION_PORT &amp; ~DIRECTION_MASK) | (st.dir_outbits &amp; DIRECTION_MASK);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">// Then pulse the stepping pins</span>
<a name="l00291"></a>00291 <span class="preprocessor">  #ifdef STEP_PULSE_DELAY</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>    st.step_bits = (STEP_PORT &amp; ~STEP_MASK) | st.step_outbits; <span class="comment">// Store out_bits to prevent overwriting.</span>
<a name="l00293"></a>00293   #<span class="keywordflow">else</span>  <span class="comment">// Normal operation</span>
<a name="l00294"></a>00294     STEP_PORT = (STEP_PORT &amp; ~STEP_MASK) | st.step_outbits;
<a name="l00295"></a>00295 <span class="preprocessor">  #endif  </span>
<a name="l00296"></a>00296 <span class="preprocessor"></span>
<a name="l00297"></a>00297   <span class="comment">// Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after</span>
<a name="l00298"></a>00298   <span class="comment">// exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.</span>
<a name="l00299"></a>00299   TCNT0 = st.step_pulse_time; <span class="comment">// Reload Timer0 counter</span>
<a name="l00300"></a>00300   TCCR0B = (1&lt;&lt;CS01); <span class="comment">// Begin Timer0. Full speed, 1/8 prescaler</span>
<a name="l00301"></a>00301 
<a name="l00302"></a>00302   busy = <span class="keyword">true</span>;
<a name="l00303"></a>00303   sei(); <span class="comment">// Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. </span>
<a name="l00304"></a>00304          <span class="comment">// NOTE: The remaining code in this ISR will finish before returning to main program.</span>
<a name="l00305"></a>00305     
<a name="l00306"></a>00306   <span class="comment">// If there is no step segment, attempt to pop one from the stepper buffer</span>
<a name="l00307"></a>00307   <span class="keywordflow">if</span> (st.exec_segment == NULL) {
<a name="l00308"></a>00308     <span class="comment">// Anything in the buffer? If so, load and initialize next step segment.</span>
<a name="l00309"></a>00309     <span class="keywordflow">if</span> (segment_buffer_head != segment_buffer_tail) {
<a name="l00310"></a>00310       <span class="comment">// Initialize new step segment and load number of steps to execute</span>
<a name="l00311"></a>00311       st.exec_segment = &amp;segment_buffer[segment_buffer_tail];
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="preprocessor">      #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>        <span class="comment">// With AMASS is disabled, set timer prescaler for segments with slow step frequencies (&lt; 250Hz).</span>
<a name="l00315"></a>00315         TCCR1B = (TCCR1B &amp; ~(0x07&lt;&lt;CS10)) | (st.exec_segment-&gt;prescaler&lt;&lt;CS10);
<a name="l00316"></a>00316 <span class="preprocessor">      #endif</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>
<a name="l00318"></a>00318       <span class="comment">// Initialize step segment timing per step and load number of steps to execute.</span>
<a name="l00319"></a>00319       OCR1A = st.exec_segment-&gt;cycles_per_tick;
<a name="l00320"></a>00320       st.step_count = st.exec_segment-&gt;n_step; <span class="comment">// NOTE: Can sometimes be zero when moving slow.</span>
<a name="l00321"></a>00321       <span class="comment">// If the new segment starts a new planner block, initialize stepper variables and counters.</span>
<a name="l00322"></a>00322       <span class="comment">// NOTE: When the segment data index changes, this indicates a new planner block.</span>
<a name="l00323"></a>00323       <span class="keywordflow">if</span> ( st.exec_block_index != st.exec_segment-&gt;st_block_index ) {
<a name="l00324"></a>00324         st.exec_block_index = st.exec_segment-&gt;st_block_index;
<a name="l00325"></a>00325         st.exec_block = &amp;st_block_buffer[st.exec_block_index];
<a name="l00326"></a>00326         
<a name="l00327"></a>00327         <span class="comment">// Initialize Bresenham line and distance counters</span>
<a name="l00328"></a>00328         st.counter_x = (st.exec_block-&gt;step_event_count &gt;&gt; 1);
<a name="l00329"></a>00329         st.counter_y = st.counter_x;
<a name="l00330"></a>00330         st.counter_z = st.counter_x;        
<a name="l00331"></a>00331       }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333       st.dir_outbits = st.exec_block-&gt;direction_bits ^ settings.<a class="code" href="structsettings__t.html#abcdfd1cefdf0eb794c1e5a5713189f15">dir_invert_mask</a>; 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="preprocessor">      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>        <span class="comment">// With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.</span>
<a name="l00337"></a>00337         st.steps[X_AXIS] = st.exec_block-&gt;steps[X_AXIS] &gt;&gt; st.exec_segment-&gt;amass_level;
<a name="l00338"></a>00338         st.steps[Y_AXIS] = st.exec_block-&gt;steps[Y_AXIS] &gt;&gt; st.exec_segment-&gt;amass_level;
<a name="l00339"></a>00339         st.steps[Z_AXIS] = st.exec_block-&gt;steps[Z_AXIS] &gt;&gt; st.exec_segment-&gt;amass_level;
<a name="l00340"></a>00340 <span class="preprocessor">      #endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>      
<a name="l00342"></a>00342     } <span class="keywordflow">else</span> {
<a name="l00343"></a>00343       <span class="comment">// Segment buffer empty. Shutdown.</span>
<a name="l00344"></a>00344       st_go_idle();
<a name="l00345"></a>00345       bit_true(sys.<a class="code" href="structsystem__t.html#aae3b4cb19307826b687519919f1c8e4f">execute</a>,EXEC_CYCLE_STOP); <span class="comment">// Flag main program for cycle end</span>
<a name="l00346"></a>00346       <span class="keywordflow">return</span>; <span class="comment">// Nothing to do but exit.</span>
<a name="l00347"></a>00347     }  
<a name="l00348"></a>00348   }
<a name="l00349"></a>00349   
<a name="l00350"></a>00350   
<a name="l00351"></a>00351   <span class="comment">// Check probing state.</span>
<a name="l00352"></a>00352   probe_state_monitor();
<a name="l00353"></a>00353    
<a name="l00354"></a>00354   <span class="comment">// Reset step out bits.</span>
<a name="l00355"></a>00355   st.step_outbits = 0; 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="comment">// Execute step displacement profile by Bresenham line algorithm</span>
<a name="l00358"></a>00358 <span class="preprocessor">  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>    st.counter_x += st.steps[X_AXIS];
<a name="l00360"></a>00360 <span class="preprocessor">  #else</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>    st.counter_x += st.exec_block-&gt;steps[X_AXIS];
<a name="l00362"></a>00362 <span class="preprocessor">  #endif  </span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (st.counter_x &gt; st.exec_block-&gt;step_event_count) {
<a name="l00364"></a>00364     st.step_outbits |= (1&lt;&lt;X_STEP_BIT);
<a name="l00365"></a>00365     st.counter_x -= st.exec_block-&gt;step_event_count;
<a name="l00366"></a>00366     <span class="keywordflow">if</span> (st.exec_block-&gt;direction_bits &amp; (1&lt;&lt;X_DIRECTION_BIT)) { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[X_AXIS]--; }
<a name="l00367"></a>00367     <span class="keywordflow">else</span> { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[X_AXIS]++; }
<a name="l00368"></a>00368   }
<a name="l00369"></a>00369 <span class="preprocessor">  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>    st.counter_y += st.steps[Y_AXIS];
<a name="l00371"></a>00371 <span class="preprocessor">  #else</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>    st.counter_y += st.exec_block-&gt;steps[Y_AXIS];
<a name="l00373"></a>00373 <span class="preprocessor">  #endif    </span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (st.counter_y &gt; st.exec_block-&gt;step_event_count) {
<a name="l00375"></a>00375     st.step_outbits |= (1&lt;&lt;Y_STEP_BIT);
<a name="l00376"></a>00376     st.counter_y -= st.exec_block-&gt;step_event_count;
<a name="l00377"></a>00377     <span class="keywordflow">if</span> (st.exec_block-&gt;direction_bits &amp; (1&lt;&lt;Y_DIRECTION_BIT)) { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[Y_AXIS]--; }
<a name="l00378"></a>00378     <span class="keywordflow">else</span> { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[Y_AXIS]++; }
<a name="l00379"></a>00379   }
<a name="l00380"></a>00380 <span class="preprocessor">  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00381"></a>00381 <span class="preprocessor"></span>    st.counter_z += st.steps[Z_AXIS];
<a name="l00382"></a>00382 <span class="preprocessor">  #else</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>    st.counter_z += st.exec_block-&gt;steps[Z_AXIS];
<a name="l00384"></a>00384 <span class="preprocessor">  #endif  </span>
<a name="l00385"></a>00385 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (st.counter_z &gt; st.exec_block-&gt;step_event_count) {
<a name="l00386"></a>00386     st.step_outbits |= (1&lt;&lt;Z_STEP_BIT);
<a name="l00387"></a>00387     st.counter_z -= st.exec_block-&gt;step_event_count;
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (st.exec_block-&gt;direction_bits &amp; (1&lt;&lt;Z_DIRECTION_BIT)) { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[Z_AXIS]--; }
<a name="l00389"></a>00389     <span class="keywordflow">else</span> { sys.<a class="code" href="structsystem__t.html#ace7899f4cc72239557bafdefb363531f">position</a>[Z_AXIS]++; }
<a name="l00390"></a>00390   }  
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="comment">// During a homing cycle, lock out and prevent desired axes from moving.</span>
<a name="l00393"></a>00393   <span class="keywordflow">if</span> (sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> == STATE_HOMING) { st.step_outbits &amp;= sys.<a class="code" href="structsystem__t.html#a8b612cb69f4879117ee76e69b00aa379">homing_axis_lock</a>; }   
<a name="l00394"></a>00394 
<a name="l00395"></a>00395   st.step_count--; <span class="comment">// Decrement step events count </span>
<a name="l00396"></a>00396   <span class="keywordflow">if</span> (st.step_count == 0) {
<a name="l00397"></a>00397     <span class="comment">// Segment is complete. Discard current segment and advance segment indexing.</span>
<a name="l00398"></a>00398     st.exec_segment = NULL;
<a name="l00399"></a>00399     <span class="keywordflow">if</span> ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
<a name="l00400"></a>00400   }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   st.step_outbits ^= settings.<a class="code" href="structsettings__t.html#aa843f4bd49fde79b30a7b414f2ebc990">step_invert_mask</a>;  <span class="comment">// Apply step port invert mask    </span>
<a name="l00403"></a>00403   busy = <span class="keyword">false</span>;
<a name="l00404"></a>00404 <span class="comment">// SPINDLE_ENABLE_PORT ^= 1&lt;&lt;SPINDLE_ENABLE_BIT; // Debug: Used to time ISR</span>
<a name="l00405"></a>00405 }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="comment">/* The Stepper Port Reset Interrupt: Timer0 OVF interrupt handles the falling edge of the step</span>
<a name="l00409"></a>00409 <span class="comment">   pulse. This should always trigger before the next Timer1 COMPA interrupt and independently</span>
<a name="l00410"></a>00410 <span class="comment">   finish, if Timer1 is disabled after completing a move.</span>
<a name="l00411"></a>00411 <span class="comment">   NOTE: Interrupt collisions between the serial and stepper interrupts can cause delays by</span>
<a name="l00412"></a>00412 <span class="comment">   a few microseconds, if they execute right before one another. Not a big deal, but can</span>
<a name="l00413"></a>00413 <span class="comment">   cause issues at high step rates if another high frequency asynchronous interrupt is </span>
<a name="l00414"></a>00414 <span class="comment">   added to Grbl.</span>
<a name="l00415"></a>00415 <span class="comment">*/</span>
<a name="l00416"></a>00416 <span class="comment">// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute</span>
<a name="l00417"></a>00417 <span class="comment">// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) </span>
<a name="l00418"></a>00418 <span class="comment">// completing one step cycle.</span>
<a name="l00419"></a>00419 ISR(TIMER0_OVF_vect)
<a name="l00420"></a>00420 {
<a name="l00421"></a>00421   <span class="comment">// Reset stepping pins (leave the direction pins)</span>
<a name="l00422"></a>00422   STEP_PORT = (STEP_PORT &amp; ~STEP_MASK) | (settings.<a class="code" href="structsettings__t.html#aa843f4bd49fde79b30a7b414f2ebc990">step_invert_mask</a> &amp; STEP_MASK); 
<a name="l00423"></a>00423   TCCR0B = 0; <span class="comment">// Disable Timer0 to prevent re-entering this interrupt when it&#39;s not needed. </span>
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 <span class="preprocessor">#ifdef STEP_PULSE_DELAY</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>  <span class="comment">// This interrupt is used only when STEP_PULSE_DELAY is enabled. Here, the step pulse is</span>
<a name="l00427"></a>00427   <span class="comment">// initiated after the STEP_PULSE_DELAY time period has elapsed. The ISR TIMER2_OVF interrupt</span>
<a name="l00428"></a>00428   <span class="comment">// will then trigger after the appropriate settings.pulse_microseconds, as in normal operation.</span>
<a name="l00429"></a>00429   <span class="comment">// The new timing between direction, step pulse, and step complete events are setup in the</span>
<a name="l00430"></a>00430   <span class="comment">// st_wake_up() routine.</span>
<a name="l00431"></a>00431   ISR(TIMER0_COMPA_vect) 
<a name="l00432"></a>00432   { 
<a name="l00433"></a>00433     STEP_PORT = st.step_bits; <span class="comment">// Begin step pulse.</span>
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435 <span class="preprocessor">#endif</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="comment">// Reset and clear stepper subsystem variables</span>
<a name="l00439"></a>00439 <span class="keywordtype">void</span> st_reset()
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441   <span class="comment">// Initialize stepper driver idle state.</span>
<a name="l00442"></a>00442   st_go_idle();
<a name="l00443"></a>00443   
<a name="l00444"></a>00444   memset(&amp;prep, 0, <span class="keyword">sizeof</span>(prep));
<a name="l00445"></a>00445   memset(&amp;st, 0, <span class="keyword">sizeof</span>(st));
<a name="l00446"></a>00446   st.exec_segment = NULL;
<a name="l00447"></a>00447   pl_block = NULL;  <span class="comment">// Planner block pointer used by segment buffer</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   segment_buffer_tail = 0;
<a name="l00450"></a>00450   segment_buffer_head = 0; <span class="comment">// empty = tail</span>
<a name="l00451"></a>00451   segment_next_head = 1;
<a name="l00452"></a>00452   busy = <span class="keyword">false</span>;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">// Initialize and start the stepper motor subsystem</span>
<a name="l00457"></a>00457 <span class="keywordtype">void</span> stepper_init()
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459   <span class="comment">// Configure step and direction interface pins</span>
<a name="l00460"></a>00460   STEP_DDR |= STEP_MASK;
<a name="l00461"></a>00461   STEP_PORT = (STEP_PORT &amp; ~STEP_MASK) | settings.<a class="code" href="structsettings__t.html#aa843f4bd49fde79b30a7b414f2ebc990">step_invert_mask</a>;
<a name="l00462"></a>00462   STEPPERS_DISABLE_DDR |= 1&lt;&lt;STEPPERS_DISABLE_BIT;
<a name="l00463"></a>00463   DIRECTION_DDR |= DIRECTION_MASK;
<a name="l00464"></a>00464   DIRECTION_PORT = (DIRECTION_PORT &amp; ~DIRECTION_MASK) | settings.<a class="code" href="structsettings__t.html#abcdfd1cefdf0eb794c1e5a5713189f15">dir_invert_mask</a>;
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   <span class="comment">// Configure Timer 1: Stepper Driver Interrupt</span>
<a name="l00467"></a>00467   TCCR1B &amp;= ~(1&lt;&lt;WGM13); <span class="comment">// waveform generation = 0100 = CTC</span>
<a name="l00468"></a>00468   TCCR1B |=  (1&lt;&lt;WGM12);
<a name="l00469"></a>00469   TCCR1A &amp;= ~((1&lt;&lt;WGM11) | (1&lt;&lt;WGM10)); 
<a name="l00470"></a>00470   TCCR1A &amp;= ~((1&lt;&lt;COM1A1) | (1&lt;&lt;COM1A0) | (1&lt;&lt;COM1B1) | (1&lt;&lt;COM1B0)); <span class="comment">// Disconnect OC1 output</span>
<a name="l00471"></a>00471   <span class="comment">// TCCR1B = (TCCR1B &amp; ~((1&lt;&lt;CS12) | (1&lt;&lt;CS11))) | (1&lt;&lt;CS10); // Set in st_go_idle().</span>
<a name="l00472"></a>00472   <span class="comment">// TIMSK1 &amp;= ~(1&lt;&lt;OCIE1A);  // Set in st_go_idle().</span>
<a name="l00473"></a>00473   
<a name="l00474"></a>00474   <span class="comment">// Configure Timer 0: Stepper Port Reset Interrupt</span>
<a name="l00475"></a>00475   TIMSK0 &amp;= ~((1&lt;&lt;OCIE0B) | (1&lt;&lt;OCIE0A) | (1&lt;&lt;TOIE0)); <span class="comment">// Disconnect OC0 outputs and OVF interrupt.</span>
<a name="l00476"></a>00476   TCCR0A = 0; <span class="comment">// Normal operation</span>
<a name="l00477"></a>00477   TCCR0B = 0; <span class="comment">// Disable Timer0 until needed</span>
<a name="l00478"></a>00478   TIMSK0 |= (1&lt;&lt;TOIE0); <span class="comment">// Enable Timer0 overflow interrupt</span>
<a name="l00479"></a>00479 <span class="preprocessor">  #ifdef STEP_PULSE_DELAY</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>    TIMSK0 |= (1&lt;&lt;OCIE0A); <span class="comment">// Enable Timer0 Compare Match A interrupt</span>
<a name="l00481"></a>00481 <span class="preprocessor">  #endif</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span>}
<a name="l00483"></a>00483   
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="comment">// Called by planner_recalculate() when the executing block is updated by the new plan.</span>
<a name="l00486"></a>00486 <span class="keywordtype">void</span> st_update_plan_block_parameters()
<a name="l00487"></a>00487 { 
<a name="l00488"></a>00488   <span class="keywordflow">if</span> (pl_block != NULL) { <span class="comment">// Ignore if at start of a new block.</span>
<a name="l00489"></a>00489     prep.flag_partial_block = <span class="keyword">true</span>;
<a name="l00490"></a>00490     pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a> = prep.current_speed*prep.current_speed; <span class="comment">// Update entry speed.</span>
<a name="l00491"></a>00491     pl_block = NULL; <span class="comment">// Flag st_prep_segment() to load new velocity profile.</span>
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="comment">/* Prepares step segment buffer. Continuously called from main program. </span>
<a name="l00497"></a>00497 <span class="comment"></span>
<a name="l00498"></a>00498 <span class="comment">   The segment buffer is an intermediary buffer interface between the execution of steps</span>
<a name="l00499"></a>00499 <span class="comment">   by the stepper algorithm and the velocity profiles generated by the planner. The stepper</span>
<a name="l00500"></a>00500 <span class="comment">   algorithm only executes steps within the segment buffer and is filled by the main program</span>
<a name="l00501"></a>00501 <span class="comment">   when steps are &quot;checked-out&quot; from the first block in the planner buffer. This keeps the</span>
<a name="l00502"></a>00502 <span class="comment">   step execution and planning optimization processes atomic and protected from each other.</span>
<a name="l00503"></a>00503 <span class="comment">   The number of steps &quot;checked-out&quot; from the planner buffer and the number of segments in</span>
<a name="l00504"></a>00504 <span class="comment">   the segment buffer is sized and computed such that no operation in the main program takes</span>
<a name="l00505"></a>00505 <span class="comment">   longer than the time it takes the stepper algorithm to empty it before refilling it. </span>
<a name="l00506"></a>00506 <span class="comment">   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.</span>
<a name="l00507"></a>00507 <span class="comment">   NOTE: Computation units are in steps, millimeters, and minutes.</span>
<a name="l00508"></a>00508 <span class="comment">*/</span>
<a name="l00509"></a>00509 <span class="keywordtype">void</span> st_prep_buffer()
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keywordflow">while</span> (segment_buffer_tail != segment_next_head) { <span class="comment">// Check if we need to fill the buffer.</span>
<a name="l00512"></a>00512 
<a name="l00513"></a>00513     <span class="comment">// Determine if we need to load a new planner block or if the block has been replanned. </span>
<a name="l00514"></a>00514     <span class="keywordflow">if</span> (pl_block == NULL) {
<a name="l00515"></a>00515       pl_block = plan_get_current_block(); <span class="comment">// Query planner for a queued block</span>
<a name="l00516"></a>00516       <span class="keywordflow">if</span> (pl_block == NULL) { <span class="keywordflow">return</span>; } <span class="comment">// No planner blocks. Exit.</span>
<a name="l00517"></a>00517                       
<a name="l00518"></a>00518       <span class="comment">// Check if the segment buffer completed the last planner block. If so, load the Bresenham</span>
<a name="l00519"></a>00519       <span class="comment">// data for the block. If not, we are still mid-block and the velocity profile was updated. </span>
<a name="l00520"></a>00520       <span class="keywordflow">if</span> (prep.flag_partial_block) {
<a name="l00521"></a>00521         prep.flag_partial_block = <span class="keyword">false</span>; <span class="comment">// Reset flag</span>
<a name="l00522"></a>00522       } <span class="keywordflow">else</span> {
<a name="l00523"></a>00523         <span class="comment">// Increment stepper common data index to store new planner block data. </span>
<a name="l00524"></a>00524         <span class="keywordflow">if</span> ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
<a name="l00525"></a>00525         
<a name="l00526"></a>00526         <span class="comment">// Prepare and copy Bresenham algorithm segment data from the new planner block, so that</span>
<a name="l00527"></a>00527         <span class="comment">// when the segment buffer completes the planner block, it may be discarded when the </span>
<a name="l00528"></a>00528         <span class="comment">// segment buffer finishes the prepped block, but the stepper ISR is still executing it. </span>
<a name="l00529"></a>00529         st_prep_block = &amp;st_block_buffer[prep.st_block_index];
<a name="l00530"></a>00530         st_prep_block-&gt;direction_bits = pl_block-&gt;<a class="code" href="structplan__block__t.html#a1c085015bed573ee1f19b5af15483e06">direction_bits</a>;
<a name="l00531"></a>00531 <span class="preprocessor">        #ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING</span>
<a name="l00532"></a>00532 <span class="preprocessor"></span>          st_prep_block-&gt;steps[X_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[X_AXIS];
<a name="l00533"></a>00533           st_prep_block-&gt;steps[Y_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[Y_AXIS];
<a name="l00534"></a>00534           st_prep_block-&gt;steps[Z_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[Z_AXIS];
<a name="l00535"></a>00535           st_prep_block-&gt;step_event_count = pl_block-&gt;<a class="code" href="structplan__block__t.html#afbdec7c54dfc0dd549aec55e03293765">step_event_count</a>;
<a name="l00536"></a>00536 <span class="preprocessor">        #else</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span>          <span class="comment">// With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS </span>
<a name="l00538"></a>00538           <span class="comment">// level, such that we never divide beyond the original data anywhere in the algorithm.</span>
<a name="l00539"></a>00539           <span class="comment">// If the original data is divided, we can lose a step from integer roundoff.</span>
<a name="l00540"></a>00540           st_prep_block-&gt;steps[X_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[X_AXIS] &lt;&lt; MAX_AMASS_LEVEL;
<a name="l00541"></a>00541           st_prep_block-&gt;steps[Y_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[Y_AXIS] &lt;&lt; MAX_AMASS_LEVEL;
<a name="l00542"></a>00542           st_prep_block-&gt;steps[Z_AXIS] = pl_block-&gt;<a class="code" href="structplan__block__t.html#ac99d0186e962055dded753786df8e2d7">steps</a>[Z_AXIS] &lt;&lt; MAX_AMASS_LEVEL;
<a name="l00543"></a>00543           st_prep_block-&gt;step_event_count = pl_block-&gt;<a class="code" href="structplan__block__t.html#afbdec7c54dfc0dd549aec55e03293765">step_event_count</a> &lt;&lt; MAX_AMASS_LEVEL;
<a name="l00544"></a>00544 <span class="preprocessor">        #endif</span>
<a name="l00545"></a>00545 <span class="preprocessor"></span>        
<a name="l00546"></a>00546         <span class="comment">// Initialize segment buffer data for generating the segments.</span>
<a name="l00547"></a>00547         prep.steps_remaining = pl_block-&gt;<a class="code" href="structplan__block__t.html#afbdec7c54dfc0dd549aec55e03293765">step_event_count</a>;
<a name="l00548"></a>00548         prep.step_per_mm = prep.steps_remaining/pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>;
<a name="l00549"></a>00549         prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
<a name="l00550"></a>00550         
<a name="l00551"></a>00551         prep.dt_remainder = 0.0; <span class="comment">// Reset for new planner block</span>
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         <span class="keywordflow">if</span> (sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> == STATE_HOLD) {
<a name="l00554"></a>00554           <span class="comment">// Override planner block entry speed and enforce deceleration during feed hold.</span>
<a name="l00555"></a>00555           prep.current_speed = prep.exit_speed; 
<a name="l00556"></a>00556           pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a> = prep.exit_speed*prep.exit_speed; 
<a name="l00557"></a>00557         }
<a name="l00558"></a>00558         <span class="keywordflow">else</span> { prep.current_speed = sqrt(pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a>); }
<a name="l00559"></a>00559       }
<a name="l00560"></a>00560      
<a name="l00561"></a>00561       <span class="comment">/* --------------------------------------------------------------------------------- </span>
<a name="l00562"></a>00562 <span class="comment">         Compute the velocity profile of a new planner block based on its entry and exit</span>
<a name="l00563"></a>00563 <span class="comment">         speeds, or recompute the profile of a partially-completed planner block if the </span>
<a name="l00564"></a>00564 <span class="comment">         planner has updated it. For a commanded forced-deceleration, such as from a feed </span>
<a name="l00565"></a>00565 <span class="comment">         hold, override the planner velocities and decelerate to the target exit speed.</span>
<a name="l00566"></a>00566 <span class="comment">      */</span>
<a name="l00567"></a>00567       prep.mm_complete = 0.0; <span class="comment">// Default velocity profile complete at 0.0mm from end of block.</span>
<a name="l00568"></a>00568       <span class="keywordtype">float</span> inv_2_accel = 0.5/pl_block-&gt;<a class="code" href="structplan__block__t.html#a853e21bbe46eac49801fc9d3f41a4e33">acceleration</a>;
<a name="l00569"></a>00569       <span class="keywordflow">if</span> (sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> == STATE_HOLD) { <span class="comment">// [Forced Deceleration to Zero Velocity]</span>
<a name="l00570"></a>00570         <span class="comment">// Compute velocity profile parameters for a feed hold in-progress. This profile overrides</span>
<a name="l00571"></a>00571         <span class="comment">// the planner block profile, enforcing a deceleration to zero speed.</span>
<a name="l00572"></a>00572         prep.ramp_type = RAMP_DECEL;
<a name="l00573"></a>00573         <span class="comment">// Compute decelerate distance relative to end of block.</span>
<a name="l00574"></a>00574         <span class="keywordtype">float</span> decel_dist = pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a> - inv_2_accel*pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a>;
<a name="l00575"></a>00575         <span class="keywordflow">if</span> (decel_dist &lt; 0.0) {
<a name="l00576"></a>00576           <span class="comment">// Deceleration through entire planner block. End of feed hold is not in this block.</span>
<a name="l00577"></a>00577           prep.exit_speed = sqrt(pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a>-2*pl_block-&gt;<a class="code" href="structplan__block__t.html#a853e21bbe46eac49801fc9d3f41a4e33">acceleration</a>*pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>);
<a name="l00578"></a>00578         } <span class="keywordflow">else</span> {
<a name="l00579"></a>00579           prep.mm_complete = decel_dist; <span class="comment">// End of feed hold.</span>
<a name="l00580"></a>00580           prep.exit_speed = 0.0;
<a name="l00581"></a>00581         }
<a name="l00582"></a>00582       } <span class="keywordflow">else</span> { <span class="comment">// [Normal Operation]</span>
<a name="l00583"></a>00583         <span class="comment">// Compute or recompute velocity profile parameters of the prepped planner block.</span>
<a name="l00584"></a>00584         prep.ramp_type = RAMP_ACCEL; <span class="comment">// Initialize as acceleration ramp.</span>
<a name="l00585"></a>00585         prep.accelerate_until = pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>; 
<a name="l00586"></a>00586         prep.exit_speed = plan_get_exec_block_exit_speed();   
<a name="l00587"></a>00587         <span class="keywordtype">float</span> exit_speed_sqr = prep.exit_speed*prep.exit_speed;
<a name="l00588"></a>00588         <span class="keywordtype">float</span> intersect_distance =
<a name="l00589"></a>00589                 0.5*(pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>+inv_2_accel*(pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a>-exit_speed_sqr));
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (intersect_distance &gt; 0.0) {
<a name="l00591"></a>00591           <span class="keywordflow">if</span> (intersect_distance &lt; pl_block-&gt;millimeters) { <span class="comment">// Either trapezoid or triangle types</span>
<a name="l00592"></a>00592             <span class="comment">// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.</span>
<a name="l00593"></a>00593             prep.decelerate_after = inv_2_accel*(pl_block-&gt;<a class="code" href="structplan__block__t.html#afbb065a4cb04713f02ba30c641205555">nominal_speed_sqr</a>-exit_speed_sqr);
<a name="l00594"></a>00594             <span class="keywordflow">if</span> (prep.decelerate_after &lt; intersect_distance) { <span class="comment">// Trapezoid type</span>
<a name="l00595"></a>00595               prep.maximum_speed = sqrt(pl_block-&gt;<a class="code" href="structplan__block__t.html#afbb065a4cb04713f02ba30c641205555">nominal_speed_sqr</a>);
<a name="l00596"></a>00596               <span class="keywordflow">if</span> (pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a> == pl_block-&gt;<a class="code" href="structplan__block__t.html#afbb065a4cb04713f02ba30c641205555">nominal_speed_sqr</a>) { 
<a name="l00597"></a>00597                 <span class="comment">// Cruise-deceleration or cruise-only type.</span>
<a name="l00598"></a>00598                 prep.ramp_type = RAMP_CRUISE;
<a name="l00599"></a>00599               } <span class="keywordflow">else</span> {
<a name="l00600"></a>00600                 <span class="comment">// Full-trapezoid or acceleration-cruise types</span>
<a name="l00601"></a>00601                 prep.accelerate_until -= inv_2_accel*(pl_block-&gt;<a class="code" href="structplan__block__t.html#afbb065a4cb04713f02ba30c641205555">nominal_speed_sqr</a>-pl_block-&gt;<a class="code" href="structplan__block__t.html#a9f7c5d3c898c5014644608bb43a65fe1">entry_speed_sqr</a>); 
<a name="l00602"></a>00602               }
<a name="l00603"></a>00603             } <span class="keywordflow">else</span> { <span class="comment">// Triangle type</span>
<a name="l00604"></a>00604               prep.accelerate_until = intersect_distance;
<a name="l00605"></a>00605               prep.decelerate_after = intersect_distance;
<a name="l00606"></a>00606               prep.maximum_speed = sqrt(2.0*pl_block-&gt;<a class="code" href="structplan__block__t.html#a853e21bbe46eac49801fc9d3f41a4e33">acceleration</a>*intersect_distance+exit_speed_sqr);
<a name="l00607"></a>00607             }          
<a name="l00608"></a>00608           } <span class="keywordflow">else</span> { <span class="comment">// Deceleration-only type</span>
<a name="l00609"></a>00609             prep.ramp_type = RAMP_DECEL;
<a name="l00610"></a>00610             <span class="comment">// prep.decelerate_after = pl_block-&gt;millimeters;</span>
<a name="l00611"></a>00611             prep.maximum_speed = prep.current_speed;
<a name="l00612"></a>00612           }
<a name="l00613"></a>00613         } <span class="keywordflow">else</span> { <span class="comment">// Acceleration-only type</span>
<a name="l00614"></a>00614           prep.accelerate_until = 0.0;
<a name="l00615"></a>00615           <span class="comment">// prep.decelerate_after = 0.0;</span>
<a name="l00616"></a>00616           prep.maximum_speed = prep.exit_speed;
<a name="l00617"></a>00617         }
<a name="l00618"></a>00618       }  
<a name="l00619"></a>00619           
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <span class="comment">// Initialize new segment</span>
<a name="l00623"></a>00623     segment_t *prep_segment = &amp;segment_buffer[segment_buffer_head];
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="comment">// Set new segment to point to the current segment data block.</span>
<a name="l00626"></a>00626     prep_segment-&gt;st_block_index = prep.st_block_index;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="comment">/*------------------------------------------------------------------------------------</span>
<a name="l00629"></a>00629 <span class="comment">        Compute the average velocity of this new segment by determining the total distance</span>
<a name="l00630"></a>00630 <span class="comment">      traveled over the segment time DT_SEGMENT. The following code first attempts to create </span>
<a name="l00631"></a>00631 <span class="comment">      a full segment based on the current ramp conditions. If the segment time is incomplete </span>
<a name="l00632"></a>00632 <span class="comment">      when terminating at a ramp state change, the code will continue to loop through the</span>
<a name="l00633"></a>00633 <span class="comment">      progressing ramp states to fill the remaining segment execution time. However, if </span>
<a name="l00634"></a>00634 <span class="comment">      an incomplete segment terminates at the end of the velocity profile, the segment is </span>
<a name="l00635"></a>00635 <span class="comment">      considered completed despite having a truncated execution time less than DT_SEGMENT.</span>
<a name="l00636"></a>00636 <span class="comment">        The velocity profile is always assumed to progress through the ramp sequence:</span>
<a name="l00637"></a>00637 <span class="comment">      acceleration ramp, cruising state, and deceleration ramp. Each ramp&#39;s travel distance</span>
<a name="l00638"></a>00638 <span class="comment">      may range from zero to the length of the block. Velocity profiles can end either at </span>
<a name="l00639"></a>00639 <span class="comment">      the end of planner block (typical) or mid-block at the end of a forced deceleration, </span>
<a name="l00640"></a>00640 <span class="comment">      such as from a feed hold.</span>
<a name="l00641"></a>00641 <span class="comment">    */</span>
<a name="l00642"></a>00642     <span class="keywordtype">float</span> dt_max = DT_SEGMENT; <span class="comment">// Maximum segment time</span>
<a name="l00643"></a>00643     <span class="keywordtype">float</span> dt = 0.0; <span class="comment">// Initialize segment time</span>
<a name="l00644"></a>00644     <span class="keywordtype">float</span> time_var = dt_max; <span class="comment">// Time worker variable</span>
<a name="l00645"></a>00645     <span class="keywordtype">float</span> mm_var; <span class="comment">// mm-Distance worker variable</span>
<a name="l00646"></a>00646     <span class="keywordtype">float</span> speed_var; <span class="comment">// Speed worker variable   </span>
<a name="l00647"></a>00647     <span class="keywordtype">float</span> mm_remaining = pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>; <span class="comment">// New segment distance from end of block.</span>
<a name="l00648"></a>00648     <span class="keywordtype">float</span> minimum_mm = mm_remaining-prep.req_mm_increment; <span class="comment">// Guarantee at least one step.</span>
<a name="l00649"></a>00649     <span class="keywordflow">if</span> (minimum_mm &lt; 0.0) { minimum_mm = 0.0; }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651     <span class="keywordflow">do</span> {
<a name="l00652"></a>00652       <span class="keywordflow">switch</span> (prep.ramp_type) {
<a name="l00653"></a>00653         <span class="keywordflow">case</span> RAMP_ACCEL: 
<a name="l00654"></a>00654           <span class="comment">// NOTE: Acceleration ramp only computes during first do-while loop.</span>
<a name="l00655"></a>00655           speed_var = pl_block-&gt;<a class="code" href="structplan__block__t.html#a853e21bbe46eac49801fc9d3f41a4e33">acceleration</a>*time_var;
<a name="l00656"></a>00656           mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
<a name="l00657"></a>00657           <span class="keywordflow">if</span> (mm_remaining &lt; prep.accelerate_until) { <span class="comment">// End of acceleration ramp.</span>
<a name="l00658"></a>00658             <span class="comment">// Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.</span>
<a name="l00659"></a>00659             mm_remaining = prep.accelerate_until; <span class="comment">// NOTE: 0.0 at EOB</span>
<a name="l00660"></a>00660             time_var = 2.0*(pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a>-mm_remaining)/(prep.current_speed+prep.maximum_speed);
<a name="l00661"></a>00661             <span class="keywordflow">if</span> (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
<a name="l00662"></a>00662             <span class="keywordflow">else</span> { prep.ramp_type = RAMP_CRUISE; }
<a name="l00663"></a>00663             prep.current_speed = prep.maximum_speed;
<a name="l00664"></a>00664           } <span class="keywordflow">else</span> { <span class="comment">// Acceleration only. </span>
<a name="l00665"></a>00665             prep.current_speed += speed_var;
<a name="l00666"></a>00666           }
<a name="l00667"></a>00667           <span class="keywordflow">break</span>;
<a name="l00668"></a>00668         <span class="keywordflow">case</span> RAMP_CRUISE: 
<a name="l00669"></a>00669           <span class="comment">// NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.</span>
<a name="l00670"></a>00670           mm_var = mm_remaining - prep.maximum_speed*time_var;
<a name="l00671"></a>00671           <span class="keywordflow">if</span> (mm_var &lt; prep.decelerate_after) { <span class="comment">// End of cruise. </span>
<a name="l00672"></a>00672             <span class="comment">// Cruise-deceleration junction or end of block.</span>
<a name="l00673"></a>00673             time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
<a name="l00674"></a>00674             mm_remaining = prep.decelerate_after; <span class="comment">// NOTE: 0.0 at EOB</span>
<a name="l00675"></a>00675             prep.ramp_type = RAMP_DECEL;
<a name="l00676"></a>00676           } <span class="keywordflow">else</span> { <span class="comment">// Cruising only.         </span>
<a name="l00677"></a>00677             mm_remaining = mm_var; 
<a name="l00678"></a>00678           } 
<a name="l00679"></a>00679           <span class="keywordflow">break</span>;
<a name="l00680"></a>00680         <span class="keywordflow">default</span>: <span class="comment">// case RAMP_DECEL:</span>
<a name="l00681"></a>00681           <span class="comment">// NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.</span>
<a name="l00682"></a>00682           speed_var = pl_block-&gt;<a class="code" href="structplan__block__t.html#a853e21bbe46eac49801fc9d3f41a4e33">acceleration</a>*time_var; <span class="comment">// Used as delta speed (mm/min)</span>
<a name="l00683"></a>00683           <span class="keywordflow">if</span> (prep.current_speed &gt; speed_var) { <span class="comment">// Check if at or below zero speed.</span>
<a name="l00684"></a>00684             <span class="comment">// Compute distance from end of segment to end of block.</span>
<a name="l00685"></a>00685             mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); <span class="comment">// (mm)</span>
<a name="l00686"></a>00686             <span class="keywordflow">if</span> (mm_var &gt; prep.mm_complete) { <span class="comment">// Deceleration only.</span>
<a name="l00687"></a>00687               mm_remaining = mm_var;
<a name="l00688"></a>00688               prep.current_speed -= speed_var;
<a name="l00689"></a>00689               <span class="keywordflow">break</span>; <span class="comment">// Segment complete. Exit switch-case statement. Continue do-while loop.</span>
<a name="l00690"></a>00690             }
<a name="l00691"></a>00691           } <span class="comment">// End of block or end of forced-deceleration.</span>
<a name="l00692"></a>00692           time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
<a name="l00693"></a>00693           mm_remaining = prep.mm_complete; 
<a name="l00694"></a>00694       }
<a name="l00695"></a>00695       dt += time_var; <span class="comment">// Add computed ramp time to total segment time.</span>
<a name="l00696"></a>00696       <span class="keywordflow">if</span> (dt &lt; dt_max) { time_var = dt_max - dt; } <span class="comment">// **Incomplete** At ramp junction.</span>
<a name="l00697"></a>00697       <span class="keywordflow">else</span> {
<a name="l00698"></a>00698         <span class="keywordflow">if</span> (mm_remaining &gt; minimum_mm) { <span class="comment">// Check for very slow segments with zero steps.</span>
<a name="l00699"></a>00699           <span class="comment">// Increase segment time to ensure at least one step in segment. Override and loop</span>
<a name="l00700"></a>00700           <span class="comment">// through distance calculations until minimum_mm or mm_complete.</span>
<a name="l00701"></a>00701           dt_max += DT_SEGMENT;
<a name="l00702"></a>00702           time_var = dt_max - dt;
<a name="l00703"></a>00703         } <span class="keywordflow">else</span> { 
<a name="l00704"></a>00704           <span class="keywordflow">break</span>; <span class="comment">// **Complete** Exit loop. Segment execution time maxed.</span>
<a name="l00705"></a>00705         }
<a name="l00706"></a>00706       }
<a name="l00707"></a>00707     } <span class="keywordflow">while</span> (mm_remaining &gt; prep.mm_complete); <span class="comment">// **Complete** Exit loop. Profile complete.</span>
<a name="l00708"></a>00708 
<a name="l00709"></a>00709    
<a name="l00710"></a>00710     <span class="comment">/* -----------------------------------------------------------------------------------</span>
<a name="l00711"></a>00711 <span class="comment">       Compute segment step rate, steps to execute, and apply necessary rate corrections.</span>
<a name="l00712"></a>00712 <span class="comment">       NOTE: Steps are computed by direct scalar conversion of the millimeter distance </span>
<a name="l00713"></a>00713 <span class="comment">       remaining in the block, rather than incrementally tallying the steps executed per</span>
<a name="l00714"></a>00714 <span class="comment">       segment. This helps in removing floating point round-off issues of several additions. </span>
<a name="l00715"></a>00715 <span class="comment">       However, since floats have only 7.2 significant digits, long moves with extremely </span>
<a name="l00716"></a>00716 <span class="comment">       high step counts can exceed the precision of floats, which can lead to lost steps.</span>
<a name="l00717"></a>00717 <span class="comment">       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines</span>
<a name="l00718"></a>00718 <span class="comment">       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).</span>
<a name="l00719"></a>00719 <span class="comment">    */</span>
<a name="l00720"></a>00720     <span class="keywordtype">float</span> steps_remaining = prep.step_per_mm*mm_remaining; <span class="comment">// Convert mm_remaining to steps</span>
<a name="l00721"></a>00721     <span class="keywordtype">float</span> n_steps_remaining = ceil(steps_remaining); <span class="comment">// Round-up current steps remaining</span>
<a name="l00722"></a>00722     <span class="keywordtype">float</span> last_n_steps_remaining = ceil(prep.steps_remaining); <span class="comment">// Round-up last steps remaining</span>
<a name="l00723"></a>00723     prep_segment-&gt;n_step = last_n_steps_remaining-n_steps_remaining; <span class="comment">// Compute number of steps to execute.</span>
<a name="l00724"></a>00724     
<a name="l00725"></a>00725     <span class="comment">// Bail if we are at the end of a feed hold and don&#39;t have a step to execute.</span>
<a name="l00726"></a>00726     <span class="keywordflow">if</span> (prep_segment-&gt;n_step == 0) {
<a name="l00727"></a>00727       <span class="keywordflow">if</span> (sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> == STATE_HOLD) {
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="comment">// Less than one step to decelerate to zero speed, but already very close. AMASS </span>
<a name="l00730"></a>00730         <span class="comment">// requires full steps to execute. So, just bail.</span>
<a name="l00731"></a>00731         prep.current_speed = 0.0;
<a name="l00732"></a>00732         prep.dt_remainder = 0.0;
<a name="l00733"></a>00733         prep.steps_remaining = n_steps_remaining;
<a name="l00734"></a>00734         pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a> = prep.steps_remaining/prep.step_per_mm; <span class="comment">// Update with full steps.</span>
<a name="l00735"></a>00735         plan_cycle_reinitialize();         
<a name="l00736"></a>00736         sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> = STATE_QUEUED; 
<a name="l00737"></a>00737         <span class="keywordflow">return</span>; <span class="comment">// Segment not generated, but current step data still retained.</span>
<a name="l00738"></a>00738       }
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">// Compute segment step rate. Since steps are integers and mm distances traveled are not,</span>
<a name="l00742"></a>00742     <span class="comment">// the end of every segment can have a partial step of varying magnitudes that are not </span>
<a name="l00743"></a>00743     <span class="comment">// executed, because the stepper ISR requires whole steps due to the AMASS algorithm. To</span>
<a name="l00744"></a>00744     <span class="comment">// compensate, we track the time to execute the previous segment&#39;s partial step and simply</span>
<a name="l00745"></a>00745     <span class="comment">// apply it with the partial step distance to the current segment, so that it minutely</span>
<a name="l00746"></a>00746     <span class="comment">// adjusts the whole segment rate to keep step output exact. These rate adjustments are </span>
<a name="l00747"></a>00747     <span class="comment">// typically very small and do not adversely effect performance, but ensures that Grbl</span>
<a name="l00748"></a>00748     <span class="comment">// outputs the exact acceleration and velocity profiles as computed by the planner.</span>
<a name="l00749"></a>00749     dt += prep.dt_remainder; <span class="comment">// Apply previous segment partial step execute time</span>
<a name="l00750"></a>00750     <span class="keywordtype">float</span> inv_rate = dt/(last_n_steps_remaining - steps_remaining); <span class="comment">// Compute adjusted step rate inverse</span>
<a name="l00751"></a>00751     prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; <span class="comment">// Update segment partial step time</span>
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="comment">// Compute CPU cycles per step for the prepped segment.</span>
<a name="l00754"></a>00754     uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); <span class="comment">// (cycles/step)    </span>
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="preprocessor">    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        </span>
<a name="l00757"></a>00757 <span class="preprocessor"></span>      <span class="comment">// Compute step timing and multi-axis smoothing level.</span>
<a name="l00758"></a>00758       <span class="comment">// NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.</span>
<a name="l00759"></a>00759       <span class="keywordflow">if</span> (cycles &lt; AMASS_LEVEL1) { prep_segment-&gt;amass_level = 0; }
<a name="l00760"></a>00760       <span class="keywordflow">else</span> {
<a name="l00761"></a>00761         <span class="keywordflow">if</span> (cycles &lt; AMASS_LEVEL2) { prep_segment-&gt;amass_level = 1; }
<a name="l00762"></a>00762         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cycles &lt; AMASS_LEVEL3) { prep_segment-&gt;amass_level = 2; }
<a name="l00763"></a>00763         <span class="keywordflow">else</span> { prep_segment-&gt;amass_level = 3; }    
<a name="l00764"></a>00764         cycles &gt;&gt;= prep_segment-&gt;amass_level; 
<a name="l00765"></a>00765         prep_segment-&gt;n_step &lt;&lt;= prep_segment-&gt;amass_level;
<a name="l00766"></a>00766       }
<a name="l00767"></a>00767       <span class="keywordflow">if</span> (cycles &lt; (1UL &lt;&lt; 16)) { prep_segment-&gt;cycles_per_tick = cycles; } <span class="comment">// &lt; 65536 (4.1ms @ 16MHz)</span>
<a name="l00768"></a>00768       <span class="keywordflow">else</span> { prep_segment-&gt;cycles_per_tick = 0xffff; } <span class="comment">// Just set the slowest speed possible.</span>
<a name="l00769"></a>00769 <span class="preprocessor">    #else </span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>      <span class="comment">// Compute step timing and timer prescalar for normal step generation.</span>
<a name="l00771"></a>00771       <span class="keywordflow">if</span> (cycles &lt; (1UL &lt;&lt; 16)) { <span class="comment">// &lt; 65536  (4.1ms @ 16MHz)</span>
<a name="l00772"></a>00772         prep_segment-&gt;prescaler = 1; <span class="comment">// prescaler: 0</span>
<a name="l00773"></a>00773         prep_segment-&gt;cycles_per_tick = cycles;
<a name="l00774"></a>00774       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cycles &lt; (1UL &lt;&lt; 19)) { <span class="comment">// &lt; 524288 (32.8ms@16MHz)</span>
<a name="l00775"></a>00775         prep_segment-&gt;prescaler = 2; <span class="comment">// prescaler: 8</span>
<a name="l00776"></a>00776         prep_segment-&gt;cycles_per_tick = cycles &gt;&gt; 3;
<a name="l00777"></a>00777       } <span class="keywordflow">else</span> { 
<a name="l00778"></a>00778         prep_segment-&gt;prescaler = 3; <span class="comment">// prescaler: 64</span>
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (cycles &lt; (1UL &lt;&lt; 22)) { <span class="comment">// &lt; 4194304 (262ms@16MHz)</span>
<a name="l00780"></a>00780           prep_segment-&gt;cycles_per_tick =  cycles &gt;&gt; 6;
<a name="l00781"></a>00781         } <span class="keywordflow">else</span> { <span class="comment">// Just set the slowest speed possible. (Around 4 step/sec.)</span>
<a name="l00782"></a>00782           prep_segment-&gt;cycles_per_tick = 0xffff;
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784       }
<a name="l00785"></a>00785 <span class="preprocessor">    #endif</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span>
<a name="l00787"></a>00787     <span class="comment">// Segment complete! Increment segment buffer indices.</span>
<a name="l00788"></a>00788     segment_buffer_head = segment_next_head;
<a name="l00789"></a>00789     <span class="keywordflow">if</span> ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="comment">// Setup initial conditions for next segment.</span>
<a name="l00792"></a>00792     <span class="keywordflow">if</span> (mm_remaining &gt; prep.mm_complete) { 
<a name="l00793"></a>00793       <span class="comment">// Normal operation. Block incomplete. Distance remaining in block to be executed.</span>
<a name="l00794"></a>00794       pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a> = mm_remaining;      
<a name="l00795"></a>00795       prep.steps_remaining = steps_remaining;  
<a name="l00796"></a>00796     } <span class="keywordflow">else</span> { 
<a name="l00797"></a>00797       <span class="comment">// End of planner block or forced-termination. No more distance to be executed.</span>
<a name="l00798"></a>00798       <span class="keywordflow">if</span> (mm_remaining &gt; 0.0) { <span class="comment">// At end of forced-termination.</span>
<a name="l00799"></a>00799         <span class="comment">// Reset prep parameters for resuming and then bail.</span>
<a name="l00800"></a>00800         <span class="comment">// NOTE: Currently only feed holds qualify for this scenario. May change with overrides.       </span>
<a name="l00801"></a>00801         prep.current_speed = 0.0;
<a name="l00802"></a>00802         prep.dt_remainder = 0.0;
<a name="l00803"></a>00803         prep.steps_remaining = ceil(steps_remaining);
<a name="l00804"></a>00804         pl_block-&gt;<a class="code" href="structplan__block__t.html#af3c23c2e926e48da1f2121e91bb5dcbf">millimeters</a> = prep.steps_remaining/prep.step_per_mm; <span class="comment">// Update with full steps.</span>
<a name="l00805"></a>00805         plan_cycle_reinitialize(); 
<a name="l00806"></a>00806         sys.<a class="code" href="structsystem__t.html#afd904a0667e42989d40551331452c451">state</a> = STATE_QUEUED; <span class="comment">// End cycle.        </span>
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="keywordflow">return</span>; <span class="comment">// Bail!</span>
<a name="l00809"></a>00809 <span class="comment">// TODO: Try to move QUEUED setting into cycle re-initialize.</span>
<a name="l00810"></a>00810 
<a name="l00811"></a>00811       } <span class="keywordflow">else</span> { <span class="comment">// End of planner block</span>
<a name="l00812"></a>00812         <span class="comment">// The planner block is complete. All steps are set to be executed in the segment buffer.</span>
<a name="l00813"></a>00813         pl_block = NULL;
<a name="l00814"></a>00814         plan_discard_current_block();
<a name="l00815"></a>00815       }
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="comment">// int32_t blength = segment_buffer_head - segment_buffer_tail;</span>
<a name="l00819"></a>00819 <span class="comment">// if (blength &lt; 0) { blength += SEGMENT_BUFFER_SIZE; } </span>
<a name="l00820"></a>00820 <span class="comment">// printInteger(blength);</span>
<a name="l00821"></a>00821   } 
<a name="l00822"></a>00822 }      
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 <span class="comment">/* </span>
<a name="l00825"></a>00825 <span class="comment">   TODO: With feedrate overrides, increases to the override value will not significantly</span>
<a name="l00826"></a>00826 <span class="comment">     change the current planner and stepper operation. When the value increases, we simply</span>
<a name="l00827"></a>00827 <span class="comment">     need to recompute the block plan with new nominal speeds and maximum junction velocities.</span>
<a name="l00828"></a>00828 <span class="comment">     However with a decreasing feedrate override, this gets a little tricky. The current block</span>
<a name="l00829"></a>00829 <span class="comment">     plan is optimal, so if we try to reduce the feed rates, it may be impossible to create </span>
<a name="l00830"></a>00830 <span class="comment">     a feasible plan at its current operating speed and decelerate down to zero at the end of</span>
<a name="l00831"></a>00831 <span class="comment">     the buffer. We first have to enforce a deceleration to meet and intersect with the reduced</span>
<a name="l00832"></a>00832 <span class="comment">     feedrate override plan. For example, if the current block is cruising at a nominal rate</span>
<a name="l00833"></a>00833 <span class="comment">     and the feedrate override is reduced, the new nominal rate will now be lower. The velocity</span>
<a name="l00834"></a>00834 <span class="comment">     profile must first decelerate to the new nominal rate and then follow on the new plan. </span>
<a name="l00835"></a>00835 <span class="comment">        Another issue is whether or not a feedrate override reduction causes a deceleration</span>
<a name="l00836"></a>00836 <span class="comment">     that acts over several planner blocks. For example, say that the plan is already heavily</span>
<a name="l00837"></a>00837 <span class="comment">     decelerating throughout it, reducing the feedrate override will not do much to it. So,</span>
<a name="l00838"></a>00838 <span class="comment">     how do we determine when to resume the new plan? One solution is to tie into the feed hold</span>
<a name="l00839"></a>00839 <span class="comment">     handling code to enforce a deceleration, but check when the current speed is less than or</span>
<a name="l00840"></a>00840 <span class="comment">     equal to the block maximum speed and is in an acceleration or cruising ramp. At this </span>
<a name="l00841"></a>00841 <span class="comment">     point, we know that we can recompute the block velocity profile to meet and continue onto</span>
<a name="l00842"></a>00842 <span class="comment">     the new block plan.</span>
<a name="l00843"></a>00843 <span class="comment">       One &quot;easy&quot; way to do this is to have the step segment buffer enforce a deceleration and</span>
<a name="l00844"></a>00844 <span class="comment">     continually re-plan the planner buffer until the plan becomes feasible. This can work</span>
<a name="l00845"></a>00845 <span class="comment">     and may be easy to implement, but it expends a lot of CPU cycles and may block out the</span>
<a name="l00846"></a>00846 <span class="comment">     rest of the functions from operating at peak efficiency. Still the question is how do </span>
<a name="l00847"></a>00847 <span class="comment">     we know when the plan is feasible in the context of what&#39;s already in the code and not</span>
<a name="l00848"></a>00848 <span class="comment">     require too much more code? </span>
<a name="l00849"></a>00849 <span class="comment">*/</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
