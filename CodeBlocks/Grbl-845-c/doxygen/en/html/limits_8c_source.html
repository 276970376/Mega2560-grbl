<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Grbl845: limits.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>limits.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">  limits.c - code pertaining to limit-switches and performing the homing cycle</span>
<a name="l00003"></a>00003 <span class="comment">  Part of Grbl</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  Copyright (c) 2009-2011 Simen Svale Skogsrud</span>
<a name="l00006"></a>00006 <span class="comment">  Copyright (c) 2012 Sungeun K. Jeon</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">  Grbl is free software: you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment">  the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00011"></a>00011 <span class="comment">  (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">  Grbl is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">  GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">  You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;util/delay.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;stepper.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;settings.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;nuts_bolts.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;spindle_control.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;motion_control.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;planner.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;protocol.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;limits.h&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#define MICROSECONDS_PER_ACCELERATION_TICK  (1000000/ACCELERATION_TICKS_PER_SECOND)</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="keywordtype">void</span> limits_init()
<a name="l00038"></a>00038 {
<a name="l00039"></a>00039   LIMIT_DDR &amp;= ~(LIMIT_MASK);
<a name="l00040"></a>00040 }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">// Moves all specified axes in same specified direction (positive=true, negative=false)</span>
<a name="l00043"></a>00043 <span class="comment">// and at the homing rate. Homing is a special motion case, where there is only an</span>
<a name="l00044"></a>00044 <span class="comment">// acceleration followed by abrupt asynchronous stops by each axes reaching their limit</span>
<a name="l00045"></a>00045 <span class="comment">// switch independently. Instead of showhorning homing cycles into the main stepper</span>
<a name="l00046"></a>00046 <span class="comment">// algorithm and overcomplicate things, a stripped-down, lite version of the stepper</span>
<a name="l00047"></a>00047 <span class="comment">// algorithm is written here. This also lets users hack and tune this code freely for</span>
<a name="l00048"></a>00048 <span class="comment">// their own particular needs without affecting the rest of Grbl.</span>
<a name="l00049"></a>00049 <span class="comment">// NOTE: Only the abort runtime command can interrupt this process.</span>
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keywordtype">void</span> homing_cycle(<span class="keywordtype">bool</span> x_axis, <span class="keywordtype">bool</span> y_axis, <span class="keywordtype">bool</span> z_axis, <span class="keywordtype">bool</span> t_axis, int8_t pos_dir, <span class="keywordtype">double</span> homing_rate)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <span class="comment">// Determine governing axes with finest step resolution per distance for the Bresenham</span>
<a name="l00053"></a>00053   <span class="comment">// algorithm. This solves the issue when homing multiple axes that have different</span>
<a name="l00054"></a>00054   <span class="comment">// resolutions without exceeding system acceleration setting. It doesn&#39;t have to be</span>
<a name="l00055"></a>00055   <span class="comment">// perfect since homing locates machine zero, but should create for a more consistent</span>
<a name="l00056"></a>00056   <span class="comment">// and speedy homing routine.</span>
<a name="l00057"></a>00057   <span class="comment">// NOTE: For each axes enabled, the following calculations assume they physically move</span>
<a name="l00058"></a>00058   <span class="comment">// an equal distance over each time step until they hit a limit switch, aka dogleg.</span><span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">/// -&gt; 843 : 4 -&gt; N_AXIS</span>
<a name="l00060"></a>00060 <span class="comment"></span>  uint32_t steps[N_AXIS];
<a name="l00061"></a>00061   clear_vector(steps);
<a name="l00062"></a>00062   <span class="keywordflow">if</span> (x_axis) {
<a name="l00063"></a>00063  steps[X_AXIS] = lround(settings.<a class="code" href="structsettings__t.html#a7e3badd978542029870fb9596255ab74" title="843 : 4 -&amp;gt; N_AXIS, X, Y, Z, T = U xor A">steps_per_mm</a>[X_AXIS]);
<a name="l00064"></a>00064   }
<a name="l00065"></a>00065   <span class="keywordflow">if</span> (y_axis)  {
<a name="l00066"></a>00066  steps[Y_AXIS] = lround(settings.<a class="code" href="structsettings__t.html#a7e3badd978542029870fb9596255ab74" title="843 : 4 -&amp;gt; N_AXIS, X, Y, Z, T = U xor A">steps_per_mm</a>[Y_AXIS]);
<a name="l00067"></a>00067   }
<a name="l00068"></a>00068   <span class="keywordflow">if</span> (z_axis) {
<a name="l00069"></a>00069  steps[Z_AXIS] = lround(settings.<a class="code" href="structsettings__t.html#a7e3badd978542029870fb9596255ab74" title="843 : 4 -&amp;gt; N_AXIS, X, Y, Z, T = U xor A">steps_per_mm</a>[Z_AXIS]);
<a name="l00070"></a>00070   }
<a name="l00071"></a>00071 <span class="comment">// 844</span>
<a name="l00072"></a>00072   <span class="keywordflow">if</span> (t_axis)  {<span class="comment"></span>
<a name="l00073"></a>00073 <span class="comment">/// 844</span>
<a name="l00074"></a>00074 <span class="comment"></span><span class="preprocessor">#if (AXIS_T_TYPE == ROTARY )</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span> steps[T_AXIS] = lround(settings.<a class="code" href="structsettings__t.html#a835a53105407526cc44c766c03ffb195" title="844">steps_per_degree</a>[T_AXIS]);
<a name="l00076"></a>00076 <span class="preprocessor">#else</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span> steps[T_AXIS] = lround(settings.<a class="code" href="structsettings__t.html#a7e3badd978542029870fb9596255ab74" title="843 : 4 -&amp;gt; N_AXIS, X, Y, Z, T = U xor A">steps_per_mm</a>[T_AXIS]);
<a name="l00078"></a>00078 <span class="preprocessor">#endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>  }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081   uint32_t step_event_count = max(steps[X_AXIS], max(steps[Y_AXIS], max(steps[Z_AXIS], steps[T_AXIS])));
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   <span class="comment">// To ensure global acceleration is not exceeded, reduce the governing axes nominal rate</span>
<a name="l00084"></a>00084   <span class="comment">// by adjusting the actual axes distance traveled per step. This is the same procedure</span>
<a name="l00085"></a>00085   <span class="comment">// used in the main planner to account for distance traveled when moving multiple axes.</span>
<a name="l00086"></a>00086   <span class="comment">// NOTE: When axis acceleration independence is installed, this will be updated to move</span>
<a name="l00087"></a>00087   <span class="comment">// all axes at their maximum acceleration and rate.</span><span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">/// 844 : axis T</span>
<a name="l00089"></a>00089 <span class="comment"></span><span class="keywordtype">double</span> ds = step_event_count/sqrt(x_axis + y_axis + z_axis + t_axis);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="comment">// Compute the adjusted step rate change with each acceleration tick. (in step/min/acceleration_tick)</span>
<a name="l00092"></a>00092   uint32_t delta_rate = ceil( ds*settings.<a class="code" href="structsettings__t.html#a706987250ef5e8f7e9b00af5c0c0727e">acceleration</a>/(60*ACCELERATION_TICKS_PER_SECOND));
<a name="l00093"></a>00093 
<a name="l00094"></a>00094   <span class="comment">// Nominal and initial time increment per step. Nominal should always be greater then 3</span>
<a name="l00095"></a>00095   <span class="comment">// usec, since they are based on the same parameters as the main stepper routine. Initial</span>
<a name="l00096"></a>00096   <span class="comment">// is based on the MINIMUM_STEPS_PER_MINUTE config.</span>
<a name="l00097"></a>00097   uint32_t dt_min = lround(1000000*60/(ds*homing_rate)); <span class="comment">// Cruising (usec/step)</span>
<a name="l00098"></a>00098   uint32_t dt = 1000000*60/MINIMUM_STEPS_PER_MINUTE; <span class="comment">// Initial (usec/step)</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <span class="comment">// Determine default out_bits set. Direction fixed and step pin inverted</span>
<a name="l00101"></a>00101   uint8_t out_bits0 = DIRECTION_MASK;
<a name="l00102"></a>00102   out_bits0 ^= settings.<a class="code" href="structsettings__t.html#aa43998f216585fea0312d83151098382">invert_mask_stepdir</a>;  <span class="comment">// Apply the global step and direction invert mask</span>
<a name="l00103"></a>00103   <span class="keywordflow">if</span> (!pos_dir) { out_bits0 ^= DIRECTION_MASK; }   <span class="comment">// Invert bits, if negative dir.</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="comment">// Initialize stepping variables</span>
<a name="l00106"></a>00106   int32_t counter_x = -(step_event_count &gt;&gt; 1); <span class="comment">// Bresenham counters</span>
<a name="l00107"></a>00107   int32_t counter_y = counter_x;
<a name="l00108"></a>00108   int32_t counter_z = counter_x;
<a name="l00109"></a>00109   int32_t counter_t = counter_x;
<a name="l00110"></a>00110   uint32_t step_delay = dt-settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>;  <span class="comment">// Step delay after pulse</span>
<a name="l00111"></a>00111   uint32_t step_rate = 0;  <span class="comment">// Tracks step rate. Initialized from 0 rate. (in step/min)</span>
<a name="l00112"></a>00112   uint32_t trap_counter = MICROSECONDS_PER_ACCELERATION_TICK/2; <span class="comment">// Acceleration trapezoid counter</span>
<a name="l00113"></a>00113   uint8_t out_bits;
<a name="l00114"></a>00114   <span class="keywordflow">for</span>(;;) {
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="comment">// Reset out bits. Both direction and step pins appropriately inverted and set.</span>
<a name="l00117"></a>00117     out_bits = out_bits0;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     <span class="comment">// Set step pins by Bresenham line algorithm. If limit switch reached, disable and</span>
<a name="l00120"></a>00120     <span class="comment">// flag for completion.</span>
<a name="l00121"></a>00121     <span class="keywordflow">if</span> (x_axis) {
<a name="l00122"></a>00122       counter_x += steps[X_AXIS];
<a name="l00123"></a>00123       <span class="keywordflow">if</span> (counter_x &gt; 0) {
<a name="l00124"></a>00124         <span class="keywordflow">if</span> (LIMIT_PIN &amp; (1&lt;&lt;X_LIMIT_BIT)) { out_bits ^= (1&lt;&lt;X_STEP_BIT); }
<a name="l00125"></a>00125         <span class="keywordflow">else</span> { x_axis = <span class="keyword">false</span>; }
<a name="l00126"></a>00126         counter_x -= step_event_count;
<a name="l00127"></a>00127       }
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     <span class="keywordflow">if</span> (y_axis) {
<a name="l00130"></a>00130       counter_y += steps[Y_AXIS];
<a name="l00131"></a>00131       <span class="keywordflow">if</span> (counter_y &gt; 0) {
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (LIMIT_PIN &amp; (1&lt;&lt;Y_LIMIT_BIT)) { out_bits ^= (1&lt;&lt;Y_STEP_BIT); }
<a name="l00133"></a>00133         <span class="keywordflow">else</span> { y_axis = <span class="keyword">false</span>; }
<a name="l00134"></a>00134         counter_y -= step_event_count;
<a name="l00135"></a>00135       }
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137     <span class="keywordflow">if</span> (z_axis) {
<a name="l00138"></a>00138       counter_z += steps[Z_AXIS];
<a name="l00139"></a>00139       <span class="keywordflow">if</span> (counter_z &gt; 0) {
<a name="l00140"></a>00140         <span class="keywordflow">if</span> (LIMIT_PIN &amp; (1&lt;&lt;Z_LIMIT_BIT)) { out_bits ^= (1&lt;&lt;Z_STEP_BIT); }
<a name="l00141"></a>00141         <span class="keywordflow">else</span> { z_axis = <span class="keyword">false</span>; }
<a name="l00142"></a>00142         counter_z -= step_event_count;
<a name="l00143"></a>00143       }
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145 <span class="comment">// 844 : axis T</span>
<a name="l00146"></a>00146     <span class="keywordflow">if</span> (t_axis) {
<a name="l00147"></a>00147       counter_t += steps[T_AXIS] ;
<a name="l00148"></a>00148       <span class="keywordflow">if</span> (counter_t &gt; 0) {
<a name="l00149"></a>00149         <span class="keywordflow">if</span> (LIMIT_PIN &amp; (1&lt;&lt;T_LIMIT_BIT))  { out_bits ^= (1&lt;&lt;T_STEP_BIT); }
<a name="l00150"></a>00150         <span class="keywordflow">else</span> { t_axis = <span class="keyword">false</span>; }
<a name="l00151"></a>00151         counter_t -= step_event_count;
<a name="l00152"></a>00152       }
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     <span class="comment">// Check if we are done or for system abort</span>
<a name="l00156"></a>00156     protocol_execute_runtime();
<a name="l00157"></a>00157     <span class="keywordflow">if</span> (!(x_axis || y_axis || z_axis || t_axis) || sys.<a class="code" href="structsystem__t.html#a81fb69e80457b3d6027c1de64b65b3c5">abort</a>) { <span class="keywordflow">return</span>; }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="comment">// Perform step.</span>
<a name="l00160"></a>00160     STEPPING_PORT = (STEPPING_PORT &amp; ~STEP_MASK) | (out_bits &amp; STEP_MASK);
<a name="l00161"></a>00161     delay_us(settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>);
<a name="l00162"></a>00162     STEPPING_PORT = out_bits0;
<a name="l00163"></a>00163     delay_us(step_delay);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <span class="comment">// Track and set the next step delay, if required. This routine uses another Bresenham</span>
<a name="l00166"></a>00166     <span class="comment">// line algorithm to follow the constant acceleration line in the velocity and time</span>
<a name="l00167"></a>00167     <span class="comment">// domain. This is a lite version of the same routine used in the main stepper program.</span>
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (dt &gt; dt_min) { <span class="comment">// Unless cruising, check for time update.</span>
<a name="l00169"></a>00169       trap_counter += dt; <span class="comment">// Track time passed since last update.</span>
<a name="l00170"></a>00170       <span class="keywordflow">if</span> (trap_counter &gt; MICROSECONDS_PER_ACCELERATION_TICK) {
<a name="l00171"></a>00171         trap_counter -= MICROSECONDS_PER_ACCELERATION_TICK;
<a name="l00172"></a>00172         step_rate += delta_rate; <span class="comment">// Increment velocity</span>
<a name="l00173"></a>00173         dt = (1000000*60)/step_rate; <span class="comment">// Compute new time increment</span>
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (dt &lt; dt_min) {dt = dt_min;}  <span class="comment">// If target rate reached, cruise.</span>
<a name="l00175"></a>00175         step_delay = dt-settings.<a class="code" href="structsettings__t.html#ac1de74c5fd7c5e2be2c46176eb7ee704">pulse_microseconds</a>;
<a name="l00176"></a>00176       }
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178   }
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">static</span> <span class="keywordtype">void</span> approach_limit_switch(<span class="keywordtype">bool</span> x, <span class="keywordtype">bool</span> y, <span class="keywordtype">bool</span> z, <span class="keywordtype">bool</span> a)
<a name="l00182"></a>00182 {
<a name="l00183"></a>00183   homing_cycle(x, y, z, a, <span class="keyword">true</span>, settings.<a class="code" href="structsettings__t.html#a75fefd30247f6a825cff8ff4c4c30029">default_seek_rate</a>);
<a name="l00184"></a>00184 }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keywordtype">void</span> leave_limit_switch(<span class="keywordtype">bool</span> x, <span class="keywordtype">bool</span> y, <span class="keywordtype">bool</span> z, <span class="keywordtype">bool</span> a) {
<a name="l00188"></a>00188   homing_cycle(x, y, z, a, <span class="keyword">false</span>, settings.<a class="code" href="structsettings__t.html#a998e899652a6c9cd367325cd62692882">default_feed_rate</a>);
<a name="l00189"></a>00189 }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keywordtype">void</span> limits_go_home()
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193   plan_synchronize();  <span class="comment">// Empty all motions in buffer.</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">// TODO: Need to come up a better way to manage and set limit switches.</span>
<a name="l00196"></a>00196   uint8_t original_limit_state = LIMIT_PIN;  <span class="comment">// Store the current limit switch state</span>
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="comment">// Jog all axes toward home to engage their limit switches.</span>
<a name="l00199"></a>00199   approach_limit_switch(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>); <span class="comment">// First home the z axis</span>
<a name="l00200"></a>00200   approach_limit_switch(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);  <span class="comment">// Then home the x, y axis</span>
<a name="l00201"></a>00201   approach_limit_switch(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);  <span class="comment">// Then home the a axis</span>
<a name="l00202"></a>00202   delay_ms(LIMIT_DEBOUNCE); <span class="comment">// Delay to debounce signal before leaving limit switches</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204   <span class="comment">// Xor previous and current limit switch state to determine which were high then but have become</span>
<a name="l00205"></a>00205   <span class="comment">// low now. These are the actual installed limit switches.</span>
<a name="l00206"></a>00206   uint8_t limit_switches_present = (original_limit_state ^ LIMIT_PIN) &amp; LIMIT_MASK;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   <span class="comment">// Now carefully leave the limit switches</span>
<a name="l00209"></a>00209   leave_limit_switch(
<a name="l00210"></a>00210   limit_switches_present &amp; (1&lt;&lt;X_LIMIT_BIT),
<a name="l00211"></a>00211   limit_switches_present &amp; (1&lt;&lt;Y_LIMIT_BIT),
<a name="l00212"></a>00212   limit_switches_present &amp; (1&lt;&lt;Z_LIMIT_BIT),
<a name="l00213"></a>00213   limit_switches_present &amp; (1&lt;&lt;T_LIMIT_BIT)
<a name="l00214"></a>00214   );
<a name="l00215"></a>00215   delay_ms(LIMIT_DEBOUNCE); <span class="comment">// Delay to debounce signal before leaving limit switches</span>
<a name="l00216"></a>00216 }
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
